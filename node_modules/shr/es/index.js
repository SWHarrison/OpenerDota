var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

import qs from 'qs';

import { isFormData, isObject, reason, append } from './utils';
import defaults from './defaults';
import xhr from './xhr';

function transformData(data, options) {
  if (!data) {
    return data;
  }
  if (isFormData(data)) {
    return data;
  }
  if (isObject(data)) {
    return qs.stringify(data);
  }
  return data;
}

function _request(url) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var adapter = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : xhr;
  var _options = options,
      _options$baseURL = _options.baseURL,
      baseURL = _options$baseURL === undefined ? '' : _options$baseURL;

  url = baseURL + url;
  var headers = Object.assign({}, defaults.headers, options.headers);
  options = Object.assign({}, defaults, options, { headers: headers });
  options.method = options.method.toUpperCase();
  if (options.transformRequest) {
    if (options.method === 'GET') {
      options.params = options.transformRequest(options.params, options);
    } else {
      options.data = options.transformRequest(options.data, options);
    }
  }
  options.data = transformData(options.data, options);
  if (!options.data || isFormData(options.data)) {
    delete options.headers['Content-Type']; // Let the browser set it
  }
  if (options.params) {
    url += (url.indexOf('?') === -1 ? '?' : '&') + qs.stringify(options.params);
  }

  return adapter(url, options).then(function (response) {
    if (options.isValid(response)) {
      if (options.transformResponse) {
        response.data = options.transformResponse(response.data, options);
      }
      return response;
    } else {
      throw reason('Invalid response', response);
    }
  });
}

var Client = function () {
  function Client(options) {
    var _this = this;

    _classCallCheck(this, Client);

    this.options = options;
    this.adapter = xhr;['put', 'patch', 'delete'].forEach(function (method) {
      _this[method] = function (url, data) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

        data = append(data, '_method', method);
        return _this.post(url, data, options);
      };
    });
  }

  _createClass(Client, [{
    key: 'request',
    value: function request(url) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      options = Object.assign({}, this.options, options);
      return _request(url, options, this.adapter);
    }
  }, {
    key: 'get',
    value: function get(url, params) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      options.method = 'get';
      options.params = params;
      return this.request(url, options);
    }
  }, {
    key: 'post',
    value: function post(url, data) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      options.method = 'post';
      options.data = data;
      return this.request(url, options);
    }
  }, {
    key: 'setAdapter',
    value: function setAdapter(adapter) {
      this.adapter = adapter;
      return this;
    }
  }]);

  return Client;
}();

export function create() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  return new Client(options);
}

export default create();

export { append };